/*******************************************************************************
*  skI2Clib - Ｉ２Ｃ関数ライブラリ(PIC12F/16F18xxシリーズ用)                   *
*             このライブラリはI2Cデバイス(RTC/EEPROM等)と接続を行う為の関数集  *
*                                                                              *
*    InterI2C       - Ｉ２Ｃ関連の割り込み処理                                 *
*    InitI2C_Master - Ｉ２Ｃ通信のマスターモードで初期化を行う処理             *
*    I2C_Start      - スレーブにスタートコンディションを発行する処理           *
*    I2C_rStart     - スレーブにリピート・スタートコンディションを発行する処理 *
*    I2C_Stop       - スレーブにストップコンディションを発行する処理           *
*    I2C_Send       - スレーブにデータを１バイト送信する処理                   *
*    I2C_Receive    - スレーブからデータを１バイト受信する処理                 *
*                                                                              *
*    メモ：SDA/SCLピンは必ず「デジタル入力ピン」に設定を行って下さい。         *
*          通信クロックは100KHz(CPU8MHz)での初期化です。                       *
* ============================================================================ *
*  VERSION DATE        BY                    CHANGE/COMMENT                    *
* ---------------------------------------------------------------------------- *
*  1.00    2012-01-20  きむ茶工房(きむしげ)  Create                            *
*  1.01    2013-02-16  きむ茶工房(きむしげ)  XC8 C Compiler 対応に変更         *
* ============================================================================ *
*  PIC 12F1822 16F18xx (16F1827はSSP2利用不可)(16F19xxは利用不可)              *
*  MPLAB IDE(V8.84)                                                            *
*  MPLAB(R) XC8 C Compiler Version 1.00                                        *
*******************************************************************************/
#include <xc.h>
#include "skI2Clib.h"

int AckCheck ;

// アイドル状態のチェック
// ACKEN RCEN PEN RSEN SEN R/W BF が全て０ならＯＫ
void I2C_IdleCheck(char mask)
{
     while (( SSP1CON2 & 0x1F ) | (SSP1STAT & mask)) ;
}
/*******************************************************************************
*  InterI2C( void )                                                            *
*    Ｉ２Ｃ関連の割り込み処理                                                  *
*     この関数はメインプログラムの割込み関数で呼びます                         *
*******************************************************************************/
void InterI2C( void )
{
     if (SSP1IF == 1) {       // SSP(I2C)割り込み発生か？
	     if (AckCheck == 1) AckCheck = 0 ;
          SSP1IF = 0 ;        // フラグクリア
     }
     if (BCL1IF == 1) {       // MSSP(I2C)バス衝突割り込み発生か？
          BCL1IF = 0 ;        // 今回はフラグのみクリアする(無処理)
     }
}
/*******************************************************************************
*  InitI2C_Master()                                                            *
*    Ｉ２Ｃ通信のマスターモードで初期化を行う処理                              *
*                                                                              *
*    注)クロック8MHzでの設定です、他のクロックはSSP1ADDを変更する必要が有ります*
*******************************************************************************/
void InitI2C_Master()
{
     SSP1STAT= 0b10000000 ;   // 標準速度モードに設定する(100kHz)
     SSP1CON1= 0b00101000 ;   // SDA/SCLピンはI2Cで使用し、マスターモードとする
     SSP1ADD = 0x13       ;   // クロック=FOSC/((SSPADD + 1)*4) 8MHz/((0x13+1)*4)=0.1(100KHz)
     SSP1IE = 1 ;             // SSP(I2C)割り込みを許可する
     BCL1IE = 1 ;             // MSSP(I2C)バス衝突割り込みを許可する
     PEIE   = 1 ;             // 周辺装置割り込みを許可する
     GIE    = 1 ;             // 全割り込み処理を許可する 
     SSP1IF = 0 ;             // SSP(I2C)割り込みフラグをクリアする
     BCL1IF = 0 ;             // MSSP(I2C)バス衝突割り込みフラグをクリアする
}
/*******************************************************************************
*  ans = I2C_Start(adrs,rw)                                                    *
*    スレーブにスタートコンディションを発行する処理                            *
*                                                                              *
*    adrs : スレーブのアドレスを指定します                                     *
*    rw   : スレーブに対する動作の指定をします                                 *
*           0=スレーブに書込みなさい要求　1=スレーブに送信しなさい要求         *
*    ans  : 0=正常　1=異常(相手からACKが返ってこない)                          *
*******************************************************************************/
int I2C_Start(int adrs,int rw)
{
     // スタート(START CONDITION)
     I2C_IdleCheck(0x5) ;
     SSP1CON2bits.SEN = 1 ;
     // [スレーブのアドレス]を送信する
     I2C_IdleCheck(0x5) ;
     AckCheck = 1 ;
     SSP1BUF = (char)((adrs<<1)+rw) ;   // アドレス + R/Wを送信
     while (AckCheck) ;                 // 相手からのACK返答を待つ
     return SSP1CON2bits.ACKSTAT ;
}
/*******************************************************************************
*  ans = I2C_rStart(adrs,rw)                                                   *
*    スレーブにリピート・スタートコンディションを発行する処理                  *
*                                                                              *
*    adrs : スレーブのアドレスを指定します                                     *
*    rw   : スレーブに対する動作の指定をします                                 *
*           0=スレーブに書込みなさい要求　1=スレーブに送信しなさい要求         *
*    ans  : 0=正常　1:異常(相手からACKが返ってこない)                          *
*******************************************************************************/
int I2C_rStart(int adrs,int rw)
{
     // リピート・スタート(REPEATED START CONDITION)
     I2C_IdleCheck(0x5) ;
     SSP1CON2bits.RSEN = 1 ;
     // [スレーブのアドレス]を送信する
     I2C_IdleCheck(0x5) ;
     AckCheck = 1 ;
     SSP1BUF = (char)((adrs<<1)+rw) ;   // アドレス + R/Wを送信
     while (AckCheck) ;                 // 相手からのACK返答を待つ
     return SSP1CON2bits.ACKSTAT ;
}
/*******************************************************************************
*  I2C_Stop()                                                                  *
*    スレーブにストップコンディションを発行する処理                            *
*******************************************************************************/
void I2C_Stop()
{
     // ストップ(STOP CONDITION)
     I2C_IdleCheck(0x5) ;
     SSP1CON2bits.PEN = 1 ;
}
/*******************************************************************************
*  ans = I2C_Send(dt)                                                          *
*    スレーブにデータを１バイト送信する処理                                    *
*                                                                              *
*    dt  : 送信するデータを指定します                                          *
*    ans  : 0=正常　1=異常(相手からACKが返ってこない又はNOACKを返した)         *
*******************************************************************************/
int I2C_Send(char dt)
{
     I2C_IdleCheck(0x5) ;
     AckCheck = 1 ;
     SSP1BUF = dt ;                     // データを送信
     while (AckCheck) ;                 // 相手からのACK返答を待つ
     return SSP1CON2bits.ACKSTAT ;
}
/*******************************************************************************
*  ans = I2C_Receive(ack)                                                      *
*    スレーブからデータを１バイト受信する処理                                  *
*                                                                              *
*    ack  : スレーブへの返答データを指定します                                 *
*           0:ACKを返す　1:NOACKを返す(受信データが最後なら1)                  *
*    ans  : 受信したデータを返す                                               *
*******************************************************************************/
char I2C_Receive(int ack)
{
	char dt ;
	
     I2C_IdleCheck(0x5) ;
     SSP1CON2bits.RCEN = 1 ;       // 受信を許可する
     I2C_IdleCheck(0x4) ;
     dt = SSP1BUF ;                // データの受信
     I2C_IdleCheck(0x5) ;
     SSP1CON2bits.ACKDT = ack ;    // ACKデータのセット
     SSP1CON2bits.ACKEN = 1 ;      // ACKデータを返す
     return dt ;
}
